export * from '@sapphire/discord-utilities';
import { isNullish, isFunction } from '@sapphire/utilities';
import { MessagePayload, MessageEmbed, Permissions } from 'discord.js';
import '@sapphire/time-utilities';

/**
 * A message builder class, it implements the {@link MessageOptions} interface.
 */
class MessageBuilder {
    constructor(options) {
        /**
         * Whether or not the message should be spoken aloud.
         * @default false
         */
        Object.defineProperty(this, "tts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The nonce for the message.
         * @default ''
         */
        Object.defineProperty(this, "nonce", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The content for the message. If set to undefined and the builder is used to edit, the content will not be
         * replaced.
         */
        Object.defineProperty(this, "content", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The embeds for the message. If set to undefined and the builder is used to edit, the embed will not be replaced.
         * @remark There is a maximum of 10 embeds in 1 message
         */
        Object.defineProperty(this, "embeds", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Which mentions should be parsed from the message content.
         */
        Object.defineProperty(this, "allowedMentions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Files to send with the message. This should not be set when editing a message, as Discord does not support
         * editing file attachments.
         */
        Object.defineProperty(this, "files", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.tts = options?.tts ?? MessageBuilder.defaults.tts;
        this.nonce = options?.nonce ?? MessageBuilder.defaults.nonce;
        this.content = options?.content ?? MessageBuilder.defaults.content;
        this.embeds = options?.embeds ?? MessageBuilder.defaults.embeds;
        this.allowedMentions = options?.allowedMentions ?? MessageBuilder.defaults.allowedMentions;
        this.files = options?.files ?? MessageBuilder.defaults.files;
    }
    /**
     * Sets the value for the {@link MessageBuilder.tts} field.
     * @param tts Whether or not the message should be spoken aloud.
     */
    setTTS(tts) {
        this.tts = tts;
        return this;
    }
    /**
     * Sets the value for the {@link MessageBuilder.nonce} field.
     * @param nonce The nonce for the message.
     */
    setNonce(nonce) {
        this.nonce = nonce;
        return this;
    }
    /**
     * Sets the value for the {@link MessageBuilder.content} field.
     * @param content The content for the message. If set to undefined and the builder is used to edit, the content will
     * not be replaced.
     */
    setContent(content) {
        this.content = content;
        return this;
    }
    /**
     * Sets the value for the {@link MessageBuilder.embed} field.
     * @param embeds The embeds for the message. If set to undefined and the builder is used to edit, the embed will not be
     * replaced. There is a maximum of 10 embeds per message
     * @remark When providing more than 10 embeds, the array will automatically be sliced down to the first 10.
     */
    setEmbeds(embeds) {
        // Ensure no more than 10 embeds are ever set
        if (embeds && embeds.length > 10) {
            embeds = embeds.slice(0, 10);
        }
        this.embeds = embeds;
        return this;
    }
    /**
     * Sets the value for the {@link MessageBuilder.allowedMentions} field.
     * @param allowedMentions Which mentions should be parsed from the message content.
     */
    setAllowedMentions(allowedMentions) {
        this.allowedMentions = allowedMentions;
        return this;
    }
    /**
     * Adds a new value for the {@link MessageBuilder.files} field array.
     * @param file The file to add to the {@link MessageBuilder.files} field array.
     */
    addFile(file) {
        this.files = this.files?.concat(file) ?? [file];
        return this;
    }
    /**
     * Sets a single value for the {@link MessageBuilder.files} field array.
     * @param file The file to send with the message. This should not be set when editing a message, as Discord does not
     * support editing file attachments.
     */
    setFile(file) {
        this.files = [file];
        return this;
    }
    /**
     * Sets the value for the {@link MessageBuilder.files} field.
     * @param files The files to send with the message. This should not be set when editing a message, as Discord does
     * not support editing file attachments.
     */
    setFiles(files) {
        this.files = files;
        return this;
    }
}
/**
 * The default values for all MessageBuilder instances.
 */
Object.defineProperty(MessageBuilder, "defaults", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: {}
});

/**
 * Checks whether a given channel is a {@link CategoryChannel}
 * @param channel The channel to check
 */
function isCategoryChannel(channel) {
    return channel?.type === 'GUILD_CATEGORY';
}
/**
 * Checks whether a given channel is a {@link DMChannel}
 * @param channel The channel to check
 */
function isDMChannel(channel) {
    return channel?.type === 'DM';
}
/**
 * Checks whether a given channel is a {@link PartialGroupDMChannel}
 * @param channel The channel to check
 */
function isGroupChannel(channel) {
    return channel?.type === 'GROUP_DM';
}
/**
 * Checks if a channel comes from a guild.
 * @param channel The channel to check
 * @returns Whether or not the channel is guild-based.
 */
function isGuildBasedChannel(channel) {
    return channel?.type !== 'DM';
}
/**
 * Checks whether or not a channel comes from a guild.
 * @remark As opposed to {@link isGuildBasedChannel} this checks if there is `guild` property on the channel.
 * @param channel The channel to check.
 * @returns Whether or not the channel is guild-based.
 */
function isGuildBasedChannelByGuildKey(channel) {
    return Reflect.has(channel ?? {}, 'guild');
}
/**
 * Checks whether a given channel is a {@link NewsChannel}.
 * @param channel The channel to check.
 */
function isNewsChannel(channel) {
    return channel?.type === 'GUILD_NEWS';
}
/**
 * Checks whether a given channel is a {@link StoreChannel}
 * @param channel The channel to check
 */
function isStoreChannel(channel) {
    return channel?.type === 'GUILD_STORE';
}
/**
 * Checks whether a given channel is a {@link TextChannel}.
 * @param channel The channel to check.
 */
function isTextChannel(channel) {
    return channel?.type === 'GUILD_TEXT';
}
/**
 * Checks whether a given channel is a {@link VoiceChannel}
 * @param channel The channel to check
 */
function isVoiceChannel(channel) {
    return channel?.type === 'GUILD_VOICE';
}
/**
 * Checks whether a given channel is a {@link StageChannel}
 * @param channel The channel to check
 */
function isStageChannel(channel) {
    return channel?.type === 'GUILD_STAGE_VOICE';
}
/**
 * Checks whether a given channel is a {@link ThreadChannel}
 * @param channel The channel to check.
 */
function isThreadChannel(channel) {
    return channel?.isThread() ?? false;
}
/**
 * Checks whether a given channel is a News {@link ThreadChannel}
 * @param channel The channel to check.
 */
function isNewsThreadChannel(channel) {
    return channel?.type === 'GUILD_NEWS_THREAD';
}
/**
 * Checks whether a given channel is a Public {@link ThreadChannel}
 * @param channel The channel to check.
 */
function isPublicThreadChannel(channel) {
    return channel?.type === 'GUILD_PUBLIC_THREAD';
}
/**
 * Checks whether a given channel is a Private {@link ThreadChannel}
 * @param channel The channel to check.
 */
function isPrivateThreadChannel(channel) {
    return channel?.type === 'GUILD_PRIVATE_THREAD';
}
/**
 * Checks whether a given channel is a {@link TextBasedChannelTypes}. This means it has a `send` method.
 * @param channel The channel to check.
 */
function isTextBasedChannel(channel) {
    if (isNullish(channel))
        return false;
    return !isNullish(channel.send);
}
/**
 * Checks whether a given channel allows NSFW content or not
 * @param channel The channel to check.
 */
function isNsfwChannel(channel) {
    if (isNullish(channel))
        return false;
    switch (channel.type) {
        case 'DM':
        case 'GROUP_DM':
        case 'GUILD_CATEGORY':
        case 'GUILD_STAGE_VOICE':
        case 'GUILD_STORE':
        case 'GUILD_VOICE':
        case 'UNKNOWN':
            return false;
        case 'GUILD_NEWS':
        case 'GUILD_TEXT':
            return channel.nsfw;
        case 'GUILD_NEWS_THREAD':
        case 'GUILD_PRIVATE_THREAD':
        case 'GUILD_PUBLIC_THREAD':
            return Boolean(channel.parent?.nsfw);
    }
}

class MessagePrompterBaseStrategy {
    /**
     * Constructor for the {@link MessagePrompterBaseStrategy} class
     * @param messagePrompter The used instance of {@link MessagePrompter}
     * @param options Overrideable options if needed.
     */
    constructor(type, message, options) {
        /**
         * The type of strategy that was used
         */
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The timeout that was used in the collector
         */
        Object.defineProperty(this, "timeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Whether to return an explicit object with data, or the strategies' default
         */
        Object.defineProperty(this, "explicitReturn", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The message that has been sent in {@link MessagePrompter.run}
         */
        Object.defineProperty(this, "appliedMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        /**
         * The message that will be sent in {@link MessagePrompter.run}
         */
        Object.defineProperty(this, "message", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The message the bot will edit to send its prompt in {@link MessagePrompter.run}
         */
        Object.defineProperty(this, "editMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.type = type;
        this.timeout = options?.timeout ?? MessagePrompterBaseStrategy.defaultStrategyOptions.timeout ?? 10 * 1000;
        this.explicitReturn = options?.explicitReturn ?? MessagePrompterBaseStrategy.defaultStrategyOptions.explicitReturn ?? false;
        this.editMessage = options?.editMessage ?? MessagePrompterBaseStrategy.defaultStrategyOptions.editMessage ?? undefined;
        this.message = message;
    }
    async collectReactions(channel, authorOrFilter, reactions) {
        if (isTextBasedChannel(channel)) {
            if (!isNullish(this.editMessage) && this.editMessage.editable) {
                this.appliedMessage = await this.editMessage.edit(this.message);
            }
            else {
                this.appliedMessage = await channel.send(this.message);
            }
            const collector = this.appliedMessage.createReactionCollector({
                ...this.createReactionPromptFilter(reactions, authorOrFilter),
                max: 1,
                time: this.timeout
            });
            let resolved = false;
            const collected = new Promise((resolve, reject) => {
                collector.on('collect', (r) => {
                    resolve(r);
                    resolved = true;
                    collector.stop();
                });
                collector.on('end', (collected) => {
                    resolved = true;
                    if (!collected.size)
                        reject(new Error('Collector has ended'));
                });
            });
            for (const reaction of reactions) {
                if (resolved)
                    break;
                await this.appliedMessage.react(reaction);
            }
            const firstReaction = await collected;
            const emoji = firstReaction?.emoji;
            const reaction = reactions.find((r) => (emoji?.id ?? emoji?.name) === r);
            return {
                emoji,
                reaction,
                strategy: this,
                appliedMessage: this.appliedMessage,
                message: this.message
            };
        }
        throw new Error('A channel was provided to which I am not able to send messages');
    }
    /**
     * Creates a filter for the collector to filter on
     * @return The filter for awaitReactions function
     */
    createReactionPromptFilter(reactions, authorOrFilter) {
        return {
            filter: async (reaction, user) => reactions.includes(reaction.emoji.id ?? reaction.emoji.name ?? '') &&
                (typeof authorOrFilter === 'function' ? await authorOrFilter(reaction, user) : user.id === authorOrFilter.id) &&
                !user.bot
        };
    }
}
/**
 * The default strategy options
 */
Object.defineProperty(MessagePrompterBaseStrategy, "defaultStrategyOptions", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: {
        timeout: 10 * 1000,
        explicitReturn: false,
        editMessage: undefined
    }
});

class MessagePrompterConfirmStrategy extends MessagePrompterBaseStrategy {
    /**
     * Constructor for the {@link MessagePrompterBaseStrategy} class
     * @param message The message to be sent {@link MessagePrompter}
     * @param options Overrideable options if needed.
     */
    constructor(message, options) {
        super('confirm', message, options);
        /**
         * The confirm emoji used
         */
        Object.defineProperty(this, "confirmEmoji", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The cancel emoji used
         */
        Object.defineProperty(this, "cancelEmoji", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.confirmEmoji = options?.confirmEmoji ?? MessagePrompterConfirmStrategy.confirmEmoji;
        this.cancelEmoji = options?.cancelEmoji ?? MessagePrompterConfirmStrategy.cancelEmoji;
    }
    /**
     * This executes the {@link MessagePrompter} and sends the message if {@link IMessagePrompterOptions.type} equals confirm.
     * The handler will wait for one (1) reaction.
     * @param channel The channel to use.
     * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/#/docs/main/stable/typedef/CollectorFilter CollectorFilter} predicate callback.
     * @returns A promise that resolves to a boolean denoting the value of the input (`true` for yes, `false` for no).
     */
    async run(channel, authorOrFilter) {
        const response = await this.collectReactions(channel, authorOrFilter, [this.confirmEmoji, this.cancelEmoji]);
        const confirmed = (response?.emoji?.id ?? response?.emoji?.name) === this.confirmEmoji;
        // prettier-ignore
        return this.explicitReturn ? { ...response, confirmed } : confirmed;
    }
}
/**
 * The default confirm emoji used for {@link MessagePrompterConfirmStrategy}
 */
Object.defineProperty(MessagePrompterConfirmStrategy, "confirmEmoji", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 'ðŸ‡¾'
});
/**
 * The default cancel emoji used for {@link MessagePrompterConfirmStrategy}
 */
Object.defineProperty(MessagePrompterConfirmStrategy, "cancelEmoji", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 'ðŸ‡³'
});

class MessagePrompterMessageStrategy extends MessagePrompterBaseStrategy {
    /**
     * Constructor for the {@link MessagePrompterBaseStrategy} class
     * @param messagePrompter The used instance of {@link MessagePrompter}
     * @param options Overrideable options if needed.
     */
    constructor(message, options) {
        super('message', message, options);
    }
    /**
     * This executes the {@link MessagePrompter} and sends the message if {@link IMessagePrompterOptions.type} equals message.
     * The handler will wait for one (1) message.
     * @param channel The channel to use.
     * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/#/docs/main/stable/typedef/CollectorFilter CollectorFilter} predicate callback.
     * @returns A promise that resolves to the message object received.
     */
    async run(channel, authorOrFilter) {
        if (isTextBasedChannel(channel)) {
            if (!isNullish(this.editMessage) && this.editMessage.editable) {
                this.appliedMessage = await this.editMessage.edit(this.message);
            }
            else {
                this.appliedMessage = await channel.send(this.message);
            }
            const collector = await channel.awaitMessages({
                ...this.createMessagePromptFilter(authorOrFilter),
                max: 1,
                time: this.timeout,
                errors: ['time']
            });
            const response = collector.first();
            if (!response) {
                throw new Error('No messages received');
            }
            return this.explicitReturn
                ? {
                    response,
                    strategy: this,
                    appliedMessage: this.appliedMessage,
                    message: this.message
                }
                : response;
        }
        throw new Error('A channel was provided to which I am not able to send messages');
    }
    /**
     * Creates a filter for the collector to filter on
     * @return The filter for awaitMessages function
     */
    createMessagePromptFilter(authorOrFilter) {
        return {
            filter: async (message) => (typeof authorOrFilter === 'function' ? await authorOrFilter(message) : message.author.id === authorOrFilter.id) &&
                !message.author.bot
        };
    }
}

class MessagePrompterNumberStrategy extends MessagePrompterBaseStrategy {
    /**
     * Constructor for the {@link MessagePrompterBaseStrategy} class
     * @param messagePrompter The used instance of {@link MessagePrompter}
     * @param options Overrideable options if needed.
     */
    constructor(message, options) {
        super('number', message, options);
        /**
         * The available number emojis
         */
        Object.defineProperty(this, "numberEmojis", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The available number emojis
         */
        Object.defineProperty(this, "start", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The available number emojis
         */
        Object.defineProperty(this, "end", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.numberEmojis = options?.numberEmojis ?? MessagePrompterNumberStrategy.numberEmojis;
        this.start = options?.start ?? 0;
        this.end = options?.end ?? 10;
    }
    /**
     * This executes the {@link MessagePrompter} and sends the message if {@link IMessagePrompterOptions.type} equals number.
     * The handler will wait for one (1) reaction.
     * @param channel The channel to use.
     * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/#/docs/main/stable/typedef/CollectorFilter CollectorFilter} predicate callback.
     * @returns A promise that resolves to the selected number within the range.
     */
    async run(channel, authorOrFilter) {
        // 0 and 10 are the maximum available emojis as a number
        if (this.start < 0)
            throw new TypeError('Starting number cannot be less than 0.');
        if (this.end > 10)
            throw new TypeError('Ending number cannot be more than 10.');
        const numbers = Array.from({ length: this.end - this.start + 1 }, (_, n) => n + this.start);
        const emojis = this.numberEmojis.slice(this.start, this.end);
        const response = await this.collectReactions(channel, authorOrFilter, emojis);
        const emojiIndex = emojis.findIndex((emoji) => (response?.emoji?.id ?? response?.emoji?.name) === emoji);
        const number = numbers[emojiIndex];
        // prettier-ignore
        return this.explicitReturn ? { ...response, number } : number;
    }
}
/**
 * The default available number emojis
 */
Object.defineProperty(MessagePrompterNumberStrategy, "numberEmojis", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: ['0ï¸âƒ£', '1ï¸âƒ£', '2ï¸âƒ£', '3ï¸âƒ£', '4ï¸âƒ£', '5ï¸âƒ£', '6ï¸âƒ£', '7ï¸âƒ£', '8ï¸âƒ£', '9ï¸âƒ£', 'ðŸ”Ÿ']
});

class MessagePrompterReactionStrategy extends MessagePrompterBaseStrategy {
    /**
     * Constructor for the {@link MessagePrompterReactionStrategy} class
     * @param messagePrompter The used instance of {@link MessagePrompter}
     * @param options Overrideable options if needed.
     */
    constructor(message, options) {
        super('reactions', message, options);
        /**
         * The emojis used
         */
        Object.defineProperty(this, "reactions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.reactions = options?.reactions;
    }
    /**
     * This executes the {@link MessagePrompterReactionStrategy} and sends the message.
     * The handler will wait for one (1) reaction.
     * @param channel The channel to use.
     * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/#/docs/main/stable/typedef/CollectorFilter CollectorFilter} predicate callback.
     * @returns A promise that resolves to the reaction object.
     */
    async run(channel, authorOrFilter) {
        if (!this.reactions?.length)
            throw new TypeError('There are no reactions provided.');
        const response = await this.collectReactions(channel, authorOrFilter, this.reactions);
        return this.explicitReturn ? response : response.reaction ?? response;
    }
}

/**
 * This is a {@link MessagePrompter}, a utility that sends a message, prompting for user input. The prompt can resolve to any kind of input.
 * There are several specifiable types to prompt for user input, and they are as follows:
 * - Confirm
 *   This will send a simple Yes/No prompt, using reactions.
 * - Number
 *   This will prompt for an integer. By default it will be a number between 0 and 10 (inclusive), however you can also specify your own custom range (inclusive).
 * - Reactions
 *   This can be any kind of reaction emoji that Discord supports, and as many as you want. This type will return that reaction instead of a boolean.
 * - Message
 *   This will prompt the user and require a response in the form of a message. This can be helpful if you require a user to upload an image for example, or give text input.
 *
 * You must either use this class directly or extend it.
 *
 * {@link MessagePrompter} uses reactions to prompt for a yes/no answer and returns it.
 * You can modify the confirm and cancel reaction used for each message, or use the {@link MessagePrompter.defaultPrompts}.
 * {@link MessagePrompter.defaultPrompts} is also static so you can modify these directly.
 *
 * @example
 * ```typescript
 * const { MessagePrompter } = require('@sapphire/discord.js-utilities');
 *
 * const handler = new MessagePrompter('Are you sure you want to continue?');
 * const result = await handler.run(channel, author);
 * ```
 *
 * @example
 * ```typescript
 * const { MessagePrompter, MessagePrompterStrategies } = require('@sapphire/discord.js-utilities');
 *
 * const handler = new MessagePrompter('Choose a number between 5 and 10?', MessagePrompterStrategies.Number, {
 * 		start: 5,
 * 		end: 10
 * });
 * const result = await handler.run(channel, author);
 * ```
 *
 * @example
 * ```typescript
 * const { MessagePrompter, MessagePrompterStrategies } = require('@sapphire/discord.js-utilities');
 *
 * const handler = new MessagePrompter('Are you happy or sad?', MessagePrompterStrategies.Reaction, {
 * 		reactions: ['ðŸ™‚', 'ðŸ™']
 * });
 * const result = await handler.run(channel, author);
 * ```
 *
 * @example
 * ```typescript
 * const { MessagePrompter, MessagePrompterStrategies } = require('@sapphire/discord.js-utilities');
 *
 * const handler = new MessagePrompter('Do you love me?', MessagePrompterStrategies.Message);
 * const result = await handler.run(channel, author);
 * ```
 */
class MessagePrompter {
    /**
     * Constructor for the {@link MessagePrompter} class
     * @param message The message to send.
     * @param strategy The strategy name or Instance to use
     * @param strategyOptions The options that are passed to the strategy
     */
    constructor(message, strategy, strategyOptions) {
        /**
         * The strategy used in {@link MessagePrompter.run}
         */
        Object.defineProperty(this, "strategy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        let strategyToRun;
        if (message instanceof MessagePrompterBaseStrategy) {
            strategyToRun = message;
        }
        else {
            const mapStrategy = MessagePrompter.strategies.get(strategy ?? MessagePrompter.defaultStrategy);
            if (!mapStrategy) {
                throw new Error('No strategy provided');
            }
            strategyToRun = new mapStrategy(message, strategyOptions);
        }
        this.strategy = strategyToRun;
    }
    /**
     * This executes the {@link MessagePrompter} and sends the message.
     * @param channel The channel to use.
     * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/#/docs/main/stable/typedef/CollectorFilter CollectorFilter} predicate callback.
     */
    run(channel, authorOrFilter) {
        return this.strategy.run(channel, authorOrFilter);
    }
}
/**
 * The available strategies
 */
Object.defineProperty(MessagePrompter, "strategies", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: new Map([
        ['confirm', MessagePrompterConfirmStrategy],
        ['number', MessagePrompterNumberStrategy],
        ['reaction', MessagePrompterReactionStrategy],
        ['message', MessagePrompterMessageStrategy]
    ])
});
/**
 * The default strategy to use
 */
Object.defineProperty(MessagePrompter, "defaultStrategy", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 'confirm'
});

/**
 * This is a {@link PaginatedMessage}, a utility to paginate messages (usually embeds).
 * You must either use this class directly or extend it.
 *
 * {@link PaginatedMessage} uses actions, these are essentially reaction emojis, when triggered run the said action.
 * You can utilize your own actions, or you can use the {@link PaginatedMessage.defaultActions}.
 * {@link PaginatedMessage.defaultActions} is also static so you can modify these directly.
 *
 * {@link PaginatedMessage} also uses pages, these are simply {@linkplain https://discord.js.org/#/docs/main/stable/class/APIMessage MessagePayloads}.
 *
 * @example
 * ```typescript
 * const myPaginatedMessage = new PaginatedMessage();
 * // Once you have an instance of PaginatedMessage you can call various methods on it to add pages to it.
 * // For more details see each method's documentation.
 *
 * myPaginatedMessage.addPageEmbed((embed) => {
 *		embed
 *			.setColor('#FF0000')
 *			.setDescription('example description');
 *
 *		return embed;
 * });
 *
 * myPaginatedMessage.addPageBuilder((builder) => {
 *		const embed = new MessageEmbed()
 *			.setColor('#FF0000')
 *			.setDescription('example description');
 *
 *		return builder
 *			.setContent('example content')
 *			.setEmbed(embed);
 * });
 *
 * myPaginatedMessage.addPageContent('Example');
 *
 * myPaginatedMessage.run(message)
 * ```
 *
 * @remark You can also provide a MessageEmbed template. This will be applied to every page.
 * If a page itself has an embed then the two will be merged, with the content of
 * the page's embed taking priority over the template.
 *
 * Furthermore, if the template has a footer then it will be applied _after_ the page index part of the footer
 * with a space preceding the template. For example, when setting `- Powered by Sapphire Framework`
 * the resulting footer will be `1/2 - Powered by Sapphire Framework`
 * @example
 * ```typescript
 * const myPaginatedMessage = new PaginatedMessage({
 * 	template: new MessageEmbed().setColor('#FF0000').setFooter('- Powered by Sapphire framework')
 * });
 * ```
 *
 * @remark To utilize actions you can implement IPaginatedMessageAction into a class.
 * @example
 * ```typescript
 * class ForwardAction implements IPaginatedMessageAction {
 *   public id = 'â–¶ï¸';
 *
 *   public run({ handler }) {
 *     if (handler.index !== handler.pages.length - 1) ++handler.index;
 *   }
 * }
 *
 * // You can also give the object directly.
 *
 * const StopAction: IPaginatedMessageAction = {
 *   id: 'â¹ï¸',
 *   disableResponseEdit: true,
 *   run: ({ response, collector }) => {
 *     await response.reactions.removeAll();
 *     collector!.stop();
 *   }
 * }
 * ```
 */
class PaginatedMessage {
    /**
     * Constructor for the {@link PaginatedMessage} class
     * @param __namedParameters The {@link PaginatedMessageOptions} for this instance of the {@link PaginatedMessage} class
     */
    constructor({ pages, actions, template, pageIndexPrefix } = {}) {
        /**
         * The pages to be converted to {@link PaginatedMessage.messages}
         */
        Object.defineProperty(this, "pages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The response message used to edit on page changes.
         */
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        /**
         * The collector used for handling reactions.
         */
        Object.defineProperty(this, "collector", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        /**
         * The pages which were converted from {@link PaginatedMessage.pages}
         */
        Object.defineProperty(this, "messages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        /**
         * The actions which are to be used.
         */
        Object.defineProperty(this, "actions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        /**
         * The handler's current page/message index.
         */
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        /**
         * The amount of milliseconds to idle before the paginator is closed. Defaults to 20 minutes.
         */
        Object.defineProperty(this, "idle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 60000 /* Minute */ * 20
        });
        /**
         * The template for this {@link PaginatedMessage}.
         * You can use templates to set defaults that will apply to each and every page in the {@link PaginatedMessage}
         */
        Object.defineProperty(this, "template", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Custom text to show in front of the page index in the embed footer.
         * PaginatedMessage will automatically add a space (` `) after the given text. You do not have to add it yourself.
         * @default ```PaginatedMessage.pageIndexPrefix``` (static property)
         */
        Object.defineProperty(this, "pageIndexPrefix", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: PaginatedMessage.pageIndexPrefix
        });
        this.pages = pages ?? [];
        for (const page of this.pages)
            this.messages.push(page instanceof MessagePayload ? page : null);
        for (const action of actions ?? this.constructor.defaultActions)
            this.actions.set(action.id, action);
        this.template = PaginatedMessage.resolveTemplate(template);
        this.pageIndexPrefix = pageIndexPrefix ?? PaginatedMessage.pageIndexPrefix;
    }
    setPromptMessage(message) {
        PaginatedMessage.promptMessage = message;
        return this;
    }
    /**
     * Sets the handler's current page/message index.
     * @param index The number to set the index to.
     */
    setIndex(index) {
        this.index = index;
        return this;
    }
    /**
     * Sets the amount of time to idle before the paginator is closed.
     * @param idle The number to set the idle to.
     */
    setIdle(idle) {
        this.idle = idle;
        return this;
    }
    /**
     * Clears all current actions and sets them. The order given is the order they will be used.
     * @param actions The actions to set.
     */
    setActions(actions) {
        this.actions.clear();
        return this.addActions(actions);
    }
    /**
     * Adds actions to the existing ones. The order given is the order they will be used.
     * @param actions The actions to add.
     */
    addActions(actions) {
        for (const action of actions)
            this.addAction(action);
        return this;
    }
    /**
     * Adds an action to the existing ones. This will be added as the last action.
     * @param action The action to add.
     */
    addAction(action) {
        this.actions.set(action.id, action);
        return this;
    }
    /**
     * Checks whether or not the handler has a specific page.
     * @param index The index to check.
     */
    hasPage(index) {
        return index >= 0 && index < this.pages.length;
    }
    /**
     * Clears all current pages and messages and sets them. The order given is the order they will be used.
     * @param pages The pages to set.
     */
    setPages(pages) {
        this.pages = [];
        this.messages = [];
        this.addPages(pages);
        return this;
    }
    /**
     * Adds a page to the existing ones. This will be added as the last page.
     * @remark While you can use this method you should first check out
     * {@link PaginatedMessage.addPageBuilder},
     * {@link PaginatedMessage.addPageContent} and
     * {@link PaginatedMessage.addPageEmbed} as
     * these are easier functional methods of adding pages and will likely already suffice for your needs.
     *
     * @param page The page to add.
     */
    addPage(page) {
        this.pages.push(page);
        this.messages.push(page instanceof MessagePayload ? page : null);
        return this;
    }
    /**
     * Adds a page to the existing ones using a {@link MessageBuilder}. This will be added as the last page.
     * @param builder Either a callback whose first parameter is `new MessageBuilder()`, or an already constructed {@link MessageBuilder}
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     * const { MessageEmbed } = require('discord.js');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageBuilder((builder) => {
     * 		const embed = new MessageEmbed()
     * 			.setColor('#FF0000')
     * 			.setDescription('example description');
     *
     * 		return builder
     * 			.setContent('example content')
     * 			.setEmbed(embed);
     * });
     * ```
     * @example
     * ```typescript
     * const { MessageEmbed } = require('discord.js');
     * const { MessageBuilder, PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const embed = new MessageEmbed()
     * 	.setColor('#FF0000')
     * 	.setDescription('example description');
     *
     * const builder = new MessageBuilder()
     * 	.setContent('example content')
     * 	.setEmbed(embed);
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageBuilder(builder);
     * ```
     */
    addPageBuilder(builder) {
        return this.addPage(isFunction(builder) ? builder(new MessageBuilder()) : builder);
    }
    /**
     * Adds a page to the existing ones asynchronously using a {@link MessageBuilder}. This wil be added as the last page.
     * @param builder Either a callback whose first parameter is `new MessageBuilder()`, or an already constructed {@link MessageBuilder}
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     * const { MessageEmbed } = require('discord.js');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addAsyncPageBuilder(async (builder) => {
     * 		const someRemoteData = await fetch('https://contoso.com/api/users');
     *
     * 		const embed = new MessageEmbed()
     * 			.setColor('#FF0000')
     * 			.setDescription(someRemoteData.data);
     *
     * 		return builder
     * 			.setContent('example content')
     * 			.setEmbed(embed);
     * });
     * ```
     */
    addAsyncPageBuilder(builder) {
        return this.addPage(async () => (isFunction(builder) ? builder(new MessageBuilder()) : builder));
    }
    /**
     * Adds a page to the existing ones using simple message content. This will be added as the last page.
     * @param content The content to set.
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageContent('example content');
     * ```
     */
    addPageContent(content) {
        return this.addPage({ content });
    }
    /**
     * Adds a page to the existing ones using a {@link MessageEmbed}. This wil be added as the last page.
     * @param embed Either a callback whose first paramter is `new MessageEmbed()`, or an already constructed {@link MessageEmbed}
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageEmbed((embed) => {
     * 		embed
     * 			.setColor('#FF0000')
     * 			.setDescription('example description');
     *
     * 		return embed;
     * });
     * ```
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const embed = new MessageEmbed()
     * 	.setColor('#FF0000')
     * 	.setDescription('example description');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageEmbed(embed);
     * ```
     */
    addPageEmbed(embed) {
        return this.addPage({ embeds: isFunction(embed) ? [embed(new MessageEmbed())] : [embed] });
    }
    /**
     * Adds a page to the existing ones asynchronously using a {@link MessageEmbed}. This wil be added as the last page.
     * @param embed Either a callback whose first paramter is `new MessageEmbed()`, or an already constructed {@link MessageEmbed}
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addAsyncPageEmbed(async (embed) => {
     *		const someRemoteData = await fetch('https://contoso.com/api/users');
     *
     * 		embed
     * 			.setColor('#FF0000')
     * 			.setDescription(someRemoteData.data);
     *
     * 		return embed;
     * });
     * ```
     */
    addAsyncPageEmbed(embed) {
        return this.addPage(async () => ({ embeds: isFunction(embed) ? [await embed(new MessageEmbed())] : [embed] }));
    }
    /**
     * Adds a page to the existing ones asynchronously using multiple {@link MessageEmbed}'s. This wil be added as the last page.
     * @remark When using this with a callback this will construct 10 {@link MessageEmbed}'s in the callback parameters, regardless of how many are actually used.
     * If this a performance impact you do not want to cope with then it is recommended to use {@link PaginatedMessage.addPageBuilder} instead, which will let you add
     * as many embeds as you want, albeit manually
     * @param embeds Either a callback which receives 10 parameters of `new MessageEmbed()`, or an array of already constructed {@link MessageEmbed}'s
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageEmbeds((embed1, embed2, embed3) => { // You can add up to 10 embeds
     * 		embed1
     * 			.setColor('#FF0000')
     * 			.setDescription('example description 1');
     *
     * 		embed2
     * 			.setColor('#00FF00')
     * 			.setDescription('example description 2');
     *
     * 		embed3
     * 			.setColor('#0000FF')
     * 			.setDescription('example description 3');
     *
     * 		return [embed1, embed2, embed3];
     * });
     * ```
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const embed1 = new MessageEmbed()
     * 	.setColor('#FF0000')
     * 	.setDescription('example description 1');
     *
     * const embed2 = new MessageEmbed()
     * 	.setColor('#00FF00')
     * 	.setDescription('example description 2');
     *
     * const embed3 = new MessageEmbed()
     * 	.setColor('#0000FF')
     * 	.setDescription('example description 3');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageEmbeds([embed1, embed2, embed3]); // You can add up to 10 embeds
     * ```
     */
    addPageEmbeds(embeds) {
        let processedEmbeds = isFunction(embeds)
            ? embeds(new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed())
            : embeds;
        if (processedEmbeds.length > 10) {
            processedEmbeds = processedEmbeds.slice(0, 10);
        }
        return this.addPage({ embeds: processedEmbeds });
    }
    /**
     * Adds a page to the existing ones using multiple {@link MessageEmbed}'s. This wil be added as the last page.
     * @remark When using this with a callback this will construct 10 {@link MessageEmbed}'s in the callback parameters, regardless of how many are actually used.
     * If this a performance impact you do not want to cope with then it is recommended to use {@link PaginatedMessage.addPageBuilder} instead, which will let you add
     * as many embeds as you want, albeit manually
     * @param embeds Either a callback which receives 10 parameters of `new MessageEmbed()`, or an array of already constructed {@link MessageEmbed}'s
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage().addAsyncPageEmbeds(async (embed0, embed1, embed2) => {
     * 	const someRemoteData = (await fetch('https://contoso.com/api/users')) as any;
     *
     * 	for (const [index, user] of Object.entries(someRemoteData.users.slice(0, 10)) as [`${0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10}`, any][]) {
     * 		switch (index) {
     * 			case '0': {
     * 				embed0.setColor('#FF0000').setDescription('example description 1').setAuthor(user.name);
     * 				break;
     * 			}
     * 			case '1': {
     * 				embed1.setColor('#00FF00').setDescription('example description 2').setAuthor(user.name);
     * 				break;
     * 			}
     * 			case '2': {
     * 				embed2.setColor('#0000FF').setDescription('example description 3').setAuthor(user.name);
     * 				break;
     * 			}
     * 		}
     * 	}
     *
     * 	return [embed0, embed1, embed2];
     * });
     * ```
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const embed1 = new MessageEmbed()
     * 	.setColor('#FF0000')
     * 	.setDescription('example description 1');
     *
     * const embed2 = new MessageEmbed()
     * 	.setColor('#00FF00')
     * 	.setDescription('example description 2');
     *
     * const embed3 = new MessageEmbed()
     * 	.setColor('#0000FF')
     * 	.setDescription('example description 3');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addAsyncPageEmbeds([embed1, embed2, embed3]); // You can add up to 10 embeds
     * ```
     */
    addAsyncPageEmbeds(embeds) {
        return this.addPage(async () => {
            let processedEmbeds = isFunction(embeds)
                ? await embeds(new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed())
                : embeds;
            if (processedEmbeds.length > 10) {
                processedEmbeds = processedEmbeds.slice(0, 10);
            }
            return { embeds: processedEmbeds };
        });
    }
    /**
     * Add pages to the existing ones. The order given is the order they will be used.
     * @param pages The pages to add.
     */
    addPages(pages) {
        for (const page of pages)
            this.addPage(page);
        return this;
    }
    /**
     * Executes the {@link PaginatedMessage} and sends the pages corresponding with {@link PaginatedMessage.index}.
     * The handler will start collecting reactions and running actions once all actions have been reacted to the message.
     * @param message The message that triggered this {@link PaginatedMessage}.
     * Generally this will be the command message, but it can also be another message from your client, i.e. to indicate a loading state.
     * @param target The user who will be able to interact with the reactions of this {@link PaginatedMessage}. Defaults to `message.author`.
     */
    async run(message, target = message.author) {
        // Try to get the previous PaginatedMessage for this user
        const paginatedMessage = PaginatedMessage.handlers.get(target.id);
        // If a PaginatedMessage was found then stop it
        if (paginatedMessage)
            paginatedMessage.collector.stop();
        // If the message was sent by a bot, then set the response as this one
        if (message.author.bot)
            this.response = message;
        await this.resolvePagesOnRun(message.channel);
        // Sanity checks to handle
        if (!this.messages.length)
            throw new Error('There are no messages.');
        if (!this.actions.size)
            throw new Error('There are no messages.');
        await this.setUpMessage(message.channel, target);
        await this.setUpReactions(message.channel, target);
        const messageId = this.response.id;
        if (this.collector) {
            this.collector.once('end', () => {
                PaginatedMessage.messages.delete(messageId);
                PaginatedMessage.handlers.delete(target.id);
            });
            PaginatedMessage.messages.set(messageId, this);
            PaginatedMessage.handlers.set(target.id, this);
        }
        return this;
    }
    /**
     * Executed whenever {@link PaginatedMessage.run} is called.
     */
    async resolvePagesOnRun(channel) {
        for (let i = 0; i < this.pages.length; i++)
            await this.resolvePage(channel, i);
    }
    /**
     * Executed whenever an action is triggered and resolved.
     * @param index The index to resolve.
     */
    async resolvePage(channel, index) {
        // If the message was already processed, do not load it again:
        const message = this.messages[index];
        if (message !== null)
            return message;
        // Load the page and return it:
        const resolved = await this.handlePageLoad(this.pages[index], channel, index);
        this.messages[index] = resolved;
        return resolved;
    }
    /**
     * Clones the current handler into a new instance.
     */
    clone() {
        const clone = new this.constructor({ pages: this.pages, actions: [] }).setIndex(this.index).setIdle(this.idle);
        clone.actions = this.actions;
        clone.response = this.response;
        clone.template = this.template;
        return clone;
    }
    async setUpMessage(channel) {
        const firstPage = this.messages[this.index];
        if (this.response)
            await this.response.edit(firstPage);
        else
            this.response = (await channel.send(firstPage));
    }
    /**
     * Sets up the message's reactions and the collector.
     * @param channel The channel the handler is running at.
     * @param author The author the handler is for.
     */
    async setUpReactions(channel, author) {
        if (this.pages.length > 1) {
            this.collector = this.response.createReactionCollector({
                filter: (reaction, user) => user.id === author.id && (this.actions.has(reaction.emoji.identifier) || this.actions.has(reaction.emoji.name ?? '')),
                idle: this.idle
            })
                .on('collect', this.handleCollect.bind(this, author, channel))
                .on('end', this.handleEnd.bind(this));
            for (const id of this.actions.keys()) {
                if (this.collector.ended)
                    break;
                await this.response.react(id);
            }
        }
    }
    /**
     * Handles the load of a page.
     * @param page The page to be loaded.
     * @param channel The channel the paginated message runs at.
     * @param index The index of the current page.
     */
    async handlePageLoad(page, channel, index) {
        const options = isFunction(page) ? await page(index, this.pages, this) : page;
        const resolved = options instanceof MessagePayload ? options : new MessagePayload(channel, this.applyTemplate(this.template, options));
        return this.applyFooter(resolved.resolveData(), index);
    }
    /**
     * Handles the `collect` event from the collector.
     * @param author The the handler is for.
     * @param channel The channel the handler is running at.
     * @param reaction The reaction that was received.
     * @param user The user that reacted to the message.
     */
    async handleCollect(author, channel, reaction, user) {
        if (isGuildBasedChannel(channel) && channel.client.user && channel.permissionsFor(channel.client.user.id)?.has('MANAGE_MESSAGES')) {
            await reaction.users.remove(user);
        }
        const action = (this.actions.get(reaction.emoji.identifier) ?? this.actions.get(reaction.emoji.name ?? ''));
        const previousIndex = this.index;
        await action.run({
            handler: this,
            author,
            channel,
            response: this.response,
            collector: this.collector
        });
        if (previousIndex !== this.index) {
            await this.response?.edit(await this.resolvePage(channel, this.index));
        }
    }
    /**
     * Handles the `end` event from the collector.
     * @param reason The reason for which the collector was ended.
     */
    async handleEnd(_, reason) {
        // Remove all listeners from the collector:
        this.collector?.removeAllListeners();
        // Do not remove reactions if the message, channel, or guild, was deleted:
        if (this.response && !PaginatedMessage.deletionStopReasons.includes(reason)) {
            if (isGuildBasedChannel(this.response.channel) &&
                this.response.client.user &&
                this.response.channel.permissionsFor(this.response.client.user.id)?.has('MANAGE_MESSAGES')) {
                await this.response.reactions.removeAll();
            }
        }
    }
    applyFooter(message, index) {
        const data = message.data;
        if (!data.embeds?.length)
            return message;
        for (const [idx, embed] of Object.entries(data.embeds)) {
            if (embed) {
                embed.footer ?? (embed.footer = { text: this.template.embeds?.[Number(idx)]?.footer?.text ?? this.template.embeds?.[0]?.footer?.text ?? '' });
                embed.footer.text = `${this.pageIndexPrefix ? `${this.pageIndexPrefix} ` : ''}${index + 1} / ${this.pages.length}${embed.footer.text ? `| ${embed.footer.text}` : ''}`;
            }
        }
        return message;
    }
    applyTemplate(template, options) {
        const embedData = this.applyTemplateEmbed(template.embeds, options.embeds);
        const embeds = embedData ? [embedData] : undefined;
        return { ...template, ...options, embeds };
    }
    applyTemplateEmbed(template, embed) {
        if (!embed)
            return template?.[0];
        if (!template)
            return embed?.[0];
        return this.mergeEmbeds(template?.[0], embed?.[0]);
    }
    mergeEmbeds(template, embed) {
        return {
            title: embed.title ?? template.title ?? undefined,
            description: embed.description ?? template.description ?? undefined,
            url: embed.url ?? template.url ?? undefined,
            timestamp: embed.timestamp ?? template.timestamp ?? undefined,
            color: embed.color ?? template.color ?? undefined,
            fields: this.mergeArrays(template.fields, embed.fields),
            author: embed.author ?? template.author ?? undefined,
            thumbnail: embed.thumbnail ?? template.thumbnail ?? undefined,
            image: embed.image ?? template.image ?? undefined,
            video: embed.video ?? template.video ?? undefined,
            footer: embed.footer ?? template.footer ?? undefined
        };
    }
    mergeArrays(template, array) {
        if (!array)
            return template;
        if (!template)
            return array;
        return [...template, ...array];
    }
    static resolveTemplate(template) {
        if (template === undefined)
            return {};
        if (template instanceof MessageEmbed)
            return { embeds: [template] };
        return template;
    }
}
/**
 * The default actions of this handler.
 */
Object.defineProperty(PaginatedMessage, "defaultActions", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: [
        {
            id: 'ðŸ”¢',
            run: async ({ handler, author, channel }) => {
                const questionMessage = await channel.send(PaginatedMessage.promptMessage);
                const collected = await channel
                    .awaitMessages({
                    filter: (message) => message.author.id === author.id,
                    max: 1,
                    idle: 60000 /* Minute */ * 20
                })
                    .catch(() => null);
                if (collected) {
                    const responseMessage = collected.first();
                    if (questionMessage.deletable)
                        await questionMessage.delete();
                    if (responseMessage) {
                        if (responseMessage.deletable)
                            await responseMessage.delete();
                        const i = Number(responseMessage.content) - 1;
                        if (!Number.isNaN(i) && handler.hasPage(i))
                            handler.index = i;
                    }
                }
            }
        },
        {
            id: 'âª',
            run: ({ handler }) => (handler.index = 0)
        },
        {
            id: 'â—€ï¸',
            run: ({ handler }) => {
                if (handler.index === 0)
                    handler.index = handler.pages.length - 1;
                else
                    --handler.index;
            }
        },
        {
            id: 'â–¶ï¸',
            run: ({ handler }) => {
                if (handler.index === handler.pages.length - 1)
                    handler.index = 0;
                else
                    ++handler.index;
            }
        },
        {
            id: 'â©',
            run: ({ handler }) => (handler.index = handler.pages.length - 1)
        },
        {
            id: 'â¹ï¸',
            run: async ({ response, collector }) => {
                if (isGuildBasedChannel(response.channel) &&
                    response.client.user &&
                    response.channel.permissionsFor(response.client.user.id)?.has('MANAGE_MESSAGES')) {
                    await response.reactions.removeAll();
                }
                collector.stop();
            }
        }
    ]
});
/**
 * The reasons sent by {@linkplain https://discord.js.org/#/docs/main/stable/class/ReactionCollector?scrollTo=e-end ReactionCollector#end}
 * event when the message (or its owner) has been deleted.
 */
Object.defineProperty(PaginatedMessage, "deletionStopReasons", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: ['messageDelete', 'channelDelete', 'guildDelete']
});
/**
 * Custom prompt message when a user wants to jump to a certain page number.
 * @default "What page would you like to jump to?"
 * @remark To overwrite this property change it in a "setup" file prior to calling `client.login()` for your bot.
 * @example
 * ```typescript
 * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
 *
 * PaginatedMessage.promptMessage = 'Please send the number of the page you would like to jump to.';
 * ```
 */
Object.defineProperty(PaginatedMessage, "promptMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 'What page would you like to jump to?'
});
/**
 * Custom text to show in front of the page index in the embed footer.
 * PaginatedMessage will automatically add a space (` `) after the given text. You do not have to add it yourself.
 * @default ""
 * @remark To overwrite this property change it somewhere in a "setup" file, i.e. where you also call `client.login()` for your bot.
 * @example
 * ```typescript
 * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
 *
 * PaginatedMessage.pageIndexPrefix = 'Page';
 * // This will make the footer of the embed something like "Page 1/2"
 * ```
 */
Object.defineProperty(PaginatedMessage, "pageIndexPrefix", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: ''
});
/**
 * The messages that are currently being handled by a {@link PaginatedMessage}
 * The key is the ID of the message that triggered this {@link PaginatedMessage}
 *
 * This is to ensure that only 1 {@link PaginatedMessage} can run on a specified message at once.
 * This is important when having an editable commands solution.
 */
Object.defineProperty(PaginatedMessage, "messages", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: new Map()
});
/**
 * The current {@link ReactionCollector} handlers that are active.
 * The key is the ID of of the author who sent the message that triggered this {@link PaginatedMessage}
 *
 * This is to ensure that any given author can only trigger 1 {@link PaginatedMessage}.
 * This is important for performance reasons, and users should not have more than 1 {@link PaginatedMessage} open at once.
 */
Object.defineProperty(PaginatedMessage, "handlers", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: new Map()
});

/**
 * This is a LazyPaginatedMessage. Instead of resolving all pages that are functions on {@link PaginatedMessage.run} will resolve when requested.
 */
class LazyPaginatedMessage extends PaginatedMessage {
    /**
     * Only resolves the page corresponding with the handler's current index.
     */
    async resolvePagesOnRun(channel) {
        await this.resolvePage(channel, this.index);
    }
    /**
     * Resolves the page corresponding with the given index. This also resolves the index's before and after the given index.
     * @param index The index to resolve. Defaults to handler's current index.
     */
    async resolvePage(channel, index) {
        const promises = [super.resolvePage(channel, index)];
        if (this.hasPage(index - 1))
            promises.push(super.resolvePage(channel, index - 1));
        if (this.hasPage(index + 1))
            promises.push(super.resolvePage(channel, index + 1));
        const [result] = await Promise.all(promises);
        return result;
    }
    addPageBuilder(builder) {
        return this.addPage(() => (isFunction(builder) ? builder(new MessageBuilder()) : builder));
    }
    addPageContent(content) {
        return this.addPage(() => ({ content }));
    }
    addPageEmbed(embed) {
        return this.addPage(() => ({ embeds: typeof embed === 'function' ? [embed(new MessageEmbed())] : [embed] }));
    }
    addPageEmbeds(embeds) {
        return this.addPage(() => {
            let processedEmbeds = isFunction(embeds)
                ? embeds(new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed())
                : embeds;
            if (processedEmbeds.length > 10) {
                processedEmbeds = processedEmbeds.slice(0, 10);
            }
            return { embeds: processedEmbeds };
        });
    }
}

/**
 * This is a utility of {@link PaginatedMessage}, except it exclusively paginates the fields of an embed.
 * You must either use this class directly or extend it.
 *
 * @example
 * ```typescript
 * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';
 *
 * new PaginatedFieldMessageEmbed()
 *    .setTitleField('Test pager field')
 *    .setTemplate({ embed })
 *    .setItems([
 *       { title: 'Sapphire Framework', value: 'discord.js Framework' },
 *       { title: 'Sapphire Framework 2', value: 'discord.js Framework 2' },
 *       { title: 'Sapphire Framework 3', value: 'discord.js Framework 3' }
 *     ])
 *    .formatItems((item) => `${item.title}\n${item.value}`)
 *    .setItemsPerPage(2)
 *    .make()
 *    .run(message);
 * ```
 */
class PaginatedFieldMessageEmbed extends PaginatedMessage {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "embedTemplate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new MessageEmbed()
        });
        Object.defineProperty(this, "totalPages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "items", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "itemsPerPage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 10
        });
        Object.defineProperty(this, "fieldTitle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ''
        });
    }
    /**
     * Set the items to paginate.
     * @param items The pages to set
     */
    setItems(items) {
        this.items = items;
        return this;
    }
    /**
     * Set the title of the embed field that will be used to paginate the items.
     * @param title The field title
     */
    setTitleField(title) {
        this.fieldTitle = title;
        return this;
    }
    /**
     * Sets the amount of items that should be shown per page.
     * @param itemsPerPage The number of items
     */
    setItemsPerPage(itemsPerPage) {
        this.itemsPerPage = itemsPerPage;
        return this;
    }
    /**
     * Sets the template to be used to display the embed fields as pages. This template can either be set from a template {@link MessageEmbed} instance or an object with embed options.
     *
     * @param template MessageEmbed
     *
     * @example
     * ```typescript
     * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';
     * import { MessageEmbed } from 'discord.js';
     *
     * new PaginatedFieldMessageEmbed().setTemplate(new MessageEmbed().setTitle('Test pager embed')).make().run(message.author, message.channel);
     * ```
     *
     * @example
     * ```typescript
     * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';
     * import { MessageEmbed } from 'discord.js';
     *
     * new PaginatedFieldMessageEmbed().setTemplate({ title: 'Test pager embed' }).make().run(message.author, message.channel);
     * ```
     */
    setTemplate(template) {
        this.embedTemplate = template instanceof MessageEmbed ? template : new MessageEmbed(template);
        return this;
    }
    /**
     * Sets a format callback that will be mapped to each embed field in the array of items when the embed is paginated. This should convert each item to a format that is either text itself or can be serialized as text.
     *
     * @example
     * ```typescript
     * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';
     *
     * new PaginatedFieldMessageEmbed()
     *    .setTitleField('Test field')
     *    .setTemplate({ embed })
     *    .setItems([
     *       { title: 'Sapphire Framework', value: 'discord.js Framework' },
     *       { title: 'Sapphire Framework 2', value: 'discord.js Framework 2' },
     *       { title: 'Sapphire Framework 3', value: 'discord.js Framework 3' }
     *     ])
     *    .formatItems((item) => `${item.title}\n${item.value}`)
     *    .make()
     *    .run(message);
     * ```
     * @param value The formatter callback to be applied to each embed item
     */
    formatItems(formatter) {
        this.items = this.items.map(formatter);
        return this;
    }
    /**
     * Build the pages of the given array.
     *
     * You must call the [[PaginatedFieldMessageEmbed.make]] and [[PaginatedFieldMessageEmbed.run]] methods last, in that order, for the pagination to work.
     *
     * @example
     * ```typescript
     * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';
     *
     * new PaginatedFieldMessageEmbed()
     *    .setTitleField('Test field')
     *    .setTemplate({ embed })
     *    .setItems([
     *       { title: 'Sapphire Framework', value: 'discord.js Framework' },
     *       { title: 'Sapphire Framework 2', value: 'discord.js Framework 2' },
     *       { title: 'Sapphire Framework 3', value: 'discord.js Framework 3' }
     *     ])
     *    .formatItems((item) => `${item.title}\n${item.value}`)
     *    .make()
     *    .run(message);
     * ```
     */
    make() {
        if (!this.fieldTitle.length)
            throw new Error('The title of the field to format must have a value.');
        if (!this.items.length)
            throw new Error('The items array is empty.');
        if (this.items.some((x) => !x))
            throw new Error('The format of the array items is incorrect.');
        this.totalPages = Math.ceil(this.items.length / this.itemsPerPage);
        this.generatePages();
        return this;
    }
    generatePages() {
        const template = this.embedTemplate instanceof MessageEmbed ? this.embedTemplate.toJSON() : this.embedTemplate;
        for (let i = 0; i < this.totalPages; i++) {
            const clonedTemplate = new MessageEmbed(template);
            const fieldsClone = this.embedTemplate.fields;
            clonedTemplate.fields = [];
            if (!clonedTemplate.color)
                clonedTemplate.setColor('RANDOM');
            const data = this.paginateArray(this.items, i, this.itemsPerPage);
            this.addPage({
                embeds: [clonedTemplate.addField(this.fieldTitle, data.join('\n'), false).addFields(fieldsClone)]
            });
        }
    }
    paginateArray(items, currentPage, perPageItems) {
        const offset = currentPage * perPageItems;
        return items.slice(offset, offset + perPageItems);
    }
}

const canReadMessagesPermissions = new Permissions(['VIEW_CHANNEL']);
/**
 * Determines whether or not we can send messages in a given channel.
 * @param channel The channel to test the permissions from.
 * @returns Whether or not we can send messages in the specified channel.
 */
function canReadMessages(channel) {
    if (isNullish(channel))
        return false;
    if (isDMChannel(channel))
        return true;
    return canDoUtility(channel, canReadMessagesPermissions);
}
const canSendMessagesPermissions = new Permissions([canReadMessagesPermissions, 'SEND_MESSAGES']);
/**
 * Determines whether or not we can send messages in a given channel.
 * @param channel The channel to test the permissions from.
 * @returns Whether or not we can send messages in the specified channel.
 */
function canSendMessages(channel) {
    if (isNullish(channel))
        return false;
    if (isDMChannel(channel))
        return true;
    if (channel.isThread() && !channel.sendable)
        return false;
    return canDoUtility(channel, canSendMessagesPermissions);
}
const canSendEmbedsPermissions = new Permissions([canSendMessagesPermissions, 'EMBED_LINKS']);
/**
 * Determines whether or not we can send embeds in a given channel.
 * @param channel The channel to test the permissions from.
 * @returns Whether or not we can send embeds in the specified channel.
 */
function canSendEmbeds(channel) {
    if (isNullish(channel))
        return false;
    if (isDMChannel(channel))
        return true;
    if (channel.isThread() && !channel.sendable)
        return false;
    return canDoUtility(channel, canSendEmbedsPermissions);
}
const canSendAttachmentsPermissions = new Permissions([canSendMessagesPermissions, 'ATTACH_FILES']);
/**
 * Determines whether or not we can send attachments in a given channel.
 * @param channel The channel to test the permissions from.
 * @returns Whether or not we can send attachments in the specified channel.
 */
function canSendAttachments(channel) {
    if (isNullish(channel))
        return false;
    if (isDMChannel(channel))
        return true;
    if (channel.isThread() && !channel.sendable)
        return false;
    return canDoUtility(channel, canSendAttachmentsPermissions);
}
const canReactPermissions = new Permissions([canSendMessagesPermissions, 'READ_MESSAGE_HISTORY', 'ADD_REACTIONS']);
/**
 * Determines whether or not we can send react to messages in a given channel.
 * @param channel The channel to test the permissions from.
 * @returns Whether or not we can react to messages in the specified channel.
 */
function canReact(channel) {
    if (isNullish(channel))
        return false;
    if (isDMChannel(channel))
        return true;
    if (channel.isThread() && channel.archived)
        return false;
    return canDoUtility(channel, canReactPermissions);
}
const canRemoveAllReactionsPermissions = new Permissions([canReadMessagesPermissions, 'READ_MESSAGE_HISTORY', 'MANAGE_MESSAGES']);
/**
 * Determines whether or not we can remove reactions from messages in a given channel.
 * @param channel The channel to test the permissions from.
 * @returns Whether or not we can remove reactions from messages in the specified channel.
 */
function canRemoveAllReactions(channel) {
    if (isNullish(channel))
        return false;
    if (isDMChannel(channel))
        return false;
    return canDoUtility(channel, canRemoveAllReactionsPermissions);
}
function canDoUtility(channel, permissionsToPass) {
    return isGuildBasedChannel(channel) ? channel.permissionsFor(channel.guild.me).has(permissionsToPass) : true;
}

export { LazyPaginatedMessage, MessageBuilder, MessagePrompter, MessagePrompterBaseStrategy, MessagePrompterConfirmStrategy, MessagePrompterMessageStrategy, MessagePrompterNumberStrategy, MessagePrompterReactionStrategy, PaginatedFieldMessageEmbed, PaginatedMessage, canReact, canReadMessages, canRemoveAllReactions, canSendAttachments, canSendEmbeds, canSendMessages, isCategoryChannel, isDMChannel, isGroupChannel, isGuildBasedChannel, isGuildBasedChannelByGuildKey, isNewsChannel, isNewsThreadChannel, isNsfwChannel, isPrivateThreadChannel, isPublicThreadChannel, isStageChannel, isStoreChannel, isTextBasedChannel, isTextChannel, isThreadChannel, isVoiceChannel };
//# sourceMappingURL=index.mjs.map
