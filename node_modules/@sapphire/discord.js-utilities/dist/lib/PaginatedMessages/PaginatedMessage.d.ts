import { Awaited } from '@sapphire/utilities';
import { Collection, Message, MessageEmbed, MessageOptions, MessagePayload, MessageReaction, ReactionCollector, Snowflake, User } from 'discord.js';
import { MessageBuilder } from '../builders/MessageBuilder';
/**
 * This is a {@link PaginatedMessage}, a utility to paginate messages (usually embeds).
 * You must either use this class directly or extend it.
 *
 * {@link PaginatedMessage} uses actions, these are essentially reaction emojis, when triggered run the said action.
 * You can utilize your own actions, or you can use the {@link PaginatedMessage.defaultActions}.
 * {@link PaginatedMessage.defaultActions} is also static so you can modify these directly.
 *
 * {@link PaginatedMessage} also uses pages, these are simply {@linkplain https://discord.js.org/#/docs/main/stable/class/APIMessage MessagePayloads}.
 *
 * @example
 * ```typescript
 * const myPaginatedMessage = new PaginatedMessage();
 * // Once you have an instance of PaginatedMessage you can call various methods on it to add pages to it.
 * // For more details see each method's documentation.
 *
 * myPaginatedMessage.addPageEmbed((embed) => {
 *		embed
 *			.setColor('#FF0000')
 *			.setDescription('example description');
 *
 *		return embed;
 * });
 *
 * myPaginatedMessage.addPageBuilder((builder) => {
 *		const embed = new MessageEmbed()
 *			.setColor('#FF0000')
 *			.setDescription('example description');
 *
 *		return builder
 *			.setContent('example content')
 *			.setEmbed(embed);
 * });
 *
 * myPaginatedMessage.addPageContent('Example');
 *
 * myPaginatedMessage.run(message)
 * ```
 *
 * @remark You can also provide a MessageEmbed template. This will be applied to every page.
 * If a page itself has an embed then the two will be merged, with the content of
 * the page's embed taking priority over the template.
 *
 * Furthermore, if the template has a footer then it will be applied _after_ the page index part of the footer
 * with a space preceding the template. For example, when setting `- Powered by Sapphire Framework`
 * the resulting footer will be `1/2 - Powered by Sapphire Framework`
 * @example
 * ```typescript
 * const myPaginatedMessage = new PaginatedMessage({
 * 	template: new MessageEmbed().setColor('#FF0000').setFooter('- Powered by Sapphire framework')
 * });
 * ```
 *
 * @remark To utilize actions you can implement IPaginatedMessageAction into a class.
 * @example
 * ```typescript
 * class ForwardAction implements IPaginatedMessageAction {
 *   public id = '▶️';
 *
 *   public run({ handler }) {
 *     if (handler.index !== handler.pages.length - 1) ++handler.index;
 *   }
 * }
 *
 * // You can also give the object directly.
 *
 * const StopAction: IPaginatedMessageAction = {
 *   id: '⏹️',
 *   disableResponseEdit: true,
 *   run: ({ response, collector }) => {
 *     await response.reactions.removeAll();
 *     collector!.stop();
 *   }
 * }
 * ```
 */
export declare class PaginatedMessage {
    /**
     * The pages to be converted to {@link PaginatedMessage.messages}
     */
    pages: MessagePage[];
    /**
     * The response message used to edit on page changes.
     */
    response: Message | null;
    /**
     * The collector used for handling reactions.
     */
    collector: ReactionCollector | null;
    /**
     * The pages which were converted from {@link PaginatedMessage.pages}
     */
    messages: (MessagePayload | null)[];
    /**
     * The actions which are to be used.
     */
    actions: Map<string, IPaginatedMessageAction>;
    /**
     * The handler's current page/message index.
     */
    index: number;
    /**
     * The amount of milliseconds to idle before the paginator is closed. Defaults to 20 minutes.
     */
    idle: number;
    /**
     * The template for this {@link PaginatedMessage}.
     * You can use templates to set defaults that will apply to each and every page in the {@link PaginatedMessage}
     */
    template: MessageOptions;
    /**
     * Custom text to show in front of the page index in the embed footer.
     * PaginatedMessage will automatically add a space (` `) after the given text. You do not have to add it yourself.
     * @default ```PaginatedMessage.pageIndexPrefix``` (static property)
     */
    pageIndexPrefix: string;
    /**
     * Constructor for the {@link PaginatedMessage} class
     * @param __namedParameters The {@link PaginatedMessageOptions} for this instance of the {@link PaginatedMessage} class
     */
    constructor({ pages, actions, template, pageIndexPrefix }?: PaginatedMessageOptions);
    setPromptMessage(message: string): this;
    /**
     * Sets the handler's current page/message index.
     * @param index The number to set the index to.
     */
    setIndex(index: number): this;
    /**
     * Sets the amount of time to idle before the paginator is closed.
     * @param idle The number to set the idle to.
     */
    setIdle(idle: number): this;
    /**
     * Clears all current actions and sets them. The order given is the order they will be used.
     * @param actions The actions to set.
     */
    setActions(actions: IPaginatedMessageAction[]): this;
    /**
     * Adds actions to the existing ones. The order given is the order they will be used.
     * @param actions The actions to add.
     */
    addActions(actions: IPaginatedMessageAction[]): this;
    /**
     * Adds an action to the existing ones. This will be added as the last action.
     * @param action The action to add.
     */
    addAction(action: IPaginatedMessageAction): this;
    /**
     * Checks whether or not the handler has a specific page.
     * @param index The index to check.
     */
    hasPage(index: number): boolean;
    /**
     * Clears all current pages and messages and sets them. The order given is the order they will be used.
     * @param pages The pages to set.
     */
    setPages(pages: MessagePage[]): this;
    /**
     * Adds a page to the existing ones. This will be added as the last page.
     * @remark While you can use this method you should first check out
     * {@link PaginatedMessage.addPageBuilder},
     * {@link PaginatedMessage.addPageContent} and
     * {@link PaginatedMessage.addPageEmbed} as
     * these are easier functional methods of adding pages and will likely already suffice for your needs.
     *
     * @param page The page to add.
     */
    addPage(page: MessagePage): this;
    /**
     * Adds a page to the existing ones using a {@link MessageBuilder}. This will be added as the last page.
     * @param builder Either a callback whose first parameter is `new MessageBuilder()`, or an already constructed {@link MessageBuilder}
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     * const { MessageEmbed } = require('discord.js');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageBuilder((builder) => {
     * 		const embed = new MessageEmbed()
     * 			.setColor('#FF0000')
     * 			.setDescription('example description');
     *
     * 		return builder
     * 			.setContent('example content')
     * 			.setEmbed(embed);
     * });
     * ```
     * @example
     * ```typescript
     * const { MessageEmbed } = require('discord.js');
     * const { MessageBuilder, PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const embed = new MessageEmbed()
     * 	.setColor('#FF0000')
     * 	.setDescription('example description');
     *
     * const builder = new MessageBuilder()
     * 	.setContent('example content')
     * 	.setEmbed(embed);
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageBuilder(builder);
     * ```
     */
    addPageBuilder(builder: MessageBuilder | ((builder: MessageBuilder) => MessageBuilder)): this;
    /**
     * Adds a page to the existing ones asynchronously using a {@link MessageBuilder}. This wil be added as the last page.
     * @param builder Either a callback whose first parameter is `new MessageBuilder()`, or an already constructed {@link MessageBuilder}
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     * const { MessageEmbed } = require('discord.js');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addAsyncPageBuilder(async (builder) => {
     * 		const someRemoteData = await fetch('https://contoso.com/api/users');
     *
     * 		const embed = new MessageEmbed()
     * 			.setColor('#FF0000')
     * 			.setDescription(someRemoteData.data);
     *
     * 		return builder
     * 			.setContent('example content')
     * 			.setEmbed(embed);
     * });
     * ```
     */
    addAsyncPageBuilder(builder: MessageBuilder | ((builder: MessageBuilder) => Promise<MessageBuilder>)): this;
    /**
     * Adds a page to the existing ones using simple message content. This will be added as the last page.
     * @param content The content to set.
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageContent('example content');
     * ```
     */
    addPageContent(content: string): this;
    /**
     * Adds a page to the existing ones using a {@link MessageEmbed}. This wil be added as the last page.
     * @param embed Either a callback whose first paramter is `new MessageEmbed()`, or an already constructed {@link MessageEmbed}
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageEmbed((embed) => {
     * 		embed
     * 			.setColor('#FF0000')
     * 			.setDescription('example description');
     *
     * 		return embed;
     * });
     * ```
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const embed = new MessageEmbed()
     * 	.setColor('#FF0000')
     * 	.setDescription('example description');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageEmbed(embed);
     * ```
     */
    addPageEmbed(embed: MessageEmbed | ((embed: MessageEmbed) => MessageEmbed)): this;
    /**
     * Adds a page to the existing ones asynchronously using a {@link MessageEmbed}. This wil be added as the last page.
     * @param embed Either a callback whose first paramter is `new MessageEmbed()`, or an already constructed {@link MessageEmbed}
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addAsyncPageEmbed(async (embed) => {
     *		const someRemoteData = await fetch('https://contoso.com/api/users');
     *
     * 		embed
     * 			.setColor('#FF0000')
     * 			.setDescription(someRemoteData.data);
     *
     * 		return embed;
     * });
     * ```
     */
    addAsyncPageEmbed(embed: MessageEmbed | ((builder: MessageEmbed) => Promise<MessageEmbed>)): this;
    /**
     * Adds a page to the existing ones asynchronously using multiple {@link MessageEmbed}'s. This wil be added as the last page.
     * @remark When using this with a callback this will construct 10 {@link MessageEmbed}'s in the callback parameters, regardless of how many are actually used.
     * If this a performance impact you do not want to cope with then it is recommended to use {@link PaginatedMessage.addPageBuilder} instead, which will let you add
     * as many embeds as you want, albeit manually
     * @param embeds Either a callback which receives 10 parameters of `new MessageEmbed()`, or an array of already constructed {@link MessageEmbed}'s
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageEmbeds((embed1, embed2, embed3) => { // You can add up to 10 embeds
     * 		embed1
     * 			.setColor('#FF0000')
     * 			.setDescription('example description 1');
     *
     * 		embed2
     * 			.setColor('#00FF00')
     * 			.setDescription('example description 2');
     *
     * 		embed3
     * 			.setColor('#0000FF')
     * 			.setDescription('example description 3');
     *
     * 		return [embed1, embed2, embed3];
     * });
     * ```
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const embed1 = new MessageEmbed()
     * 	.setColor('#FF0000')
     * 	.setDescription('example description 1');
     *
     * const embed2 = new MessageEmbed()
     * 	.setColor('#00FF00')
     * 	.setDescription('example description 2');
     *
     * const embed3 = new MessageEmbed()
     * 	.setColor('#0000FF')
     * 	.setDescription('example description 3');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageEmbeds([embed1, embed2, embed3]); // You can add up to 10 embeds
     * ```
     */
    addPageEmbeds(embeds: MessageEmbed[] | ((embed1: MessageEmbed, embed2: MessageEmbed, embed3: MessageEmbed, embed4: MessageEmbed, embed5: MessageEmbed, embed6: MessageEmbed, embed7: MessageEmbed, embed8: MessageEmbed, embed9: MessageEmbed, embed10: MessageEmbed) => MessageEmbed[])): this;
    /**
     * Adds a page to the existing ones using multiple {@link MessageEmbed}'s. This wil be added as the last page.
     * @remark When using this with a callback this will construct 10 {@link MessageEmbed}'s in the callback parameters, regardless of how many are actually used.
     * If this a performance impact you do not want to cope with then it is recommended to use {@link PaginatedMessage.addPageBuilder} instead, which will let you add
     * as many embeds as you want, albeit manually
     * @param embeds Either a callback which receives 10 parameters of `new MessageEmbed()`, or an array of already constructed {@link MessageEmbed}'s
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage().addAsyncPageEmbeds(async (embed0, embed1, embed2) => {
     * 	const someRemoteData = (await fetch('https://contoso.com/api/users')) as any;
     *
     * 	for (const [index, user] of Object.entries(someRemoteData.users.slice(0, 10)) as [`${0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10}`, any][]) {
     * 		switch (index) {
     * 			case '0': {
     * 				embed0.setColor('#FF0000').setDescription('example description 1').setAuthor(user.name);
     * 				break;
     * 			}
     * 			case '1': {
     * 				embed1.setColor('#00FF00').setDescription('example description 2').setAuthor(user.name);
     * 				break;
     * 			}
     * 			case '2': {
     * 				embed2.setColor('#0000FF').setDescription('example description 3').setAuthor(user.name);
     * 				break;
     * 			}
     * 		}
     * 	}
     *
     * 	return [embed0, embed1, embed2];
     * });
     * ```
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const embed1 = new MessageEmbed()
     * 	.setColor('#FF0000')
     * 	.setDescription('example description 1');
     *
     * const embed2 = new MessageEmbed()
     * 	.setColor('#00FF00')
     * 	.setDescription('example description 2');
     *
     * const embed3 = new MessageEmbed()
     * 	.setColor('#0000FF')
     * 	.setDescription('example description 3');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addAsyncPageEmbeds([embed1, embed2, embed3]); // You can add up to 10 embeds
     * ```
     */
    addAsyncPageEmbeds(embeds: MessageEmbed[] | ((embed1: MessageEmbed, embed2: MessageEmbed, embed3: MessageEmbed, embed4: MessageEmbed, embed5: MessageEmbed, embed6: MessageEmbed, embed7: MessageEmbed, embed8: MessageEmbed, embed9: MessageEmbed, embed10: MessageEmbed) => Promise<MessageEmbed[]>)): this;
    /**
     * Add pages to the existing ones. The order given is the order they will be used.
     * @param pages The pages to add.
     */
    addPages(pages: MessagePage[]): this;
    /**
     * Executes the {@link PaginatedMessage} and sends the pages corresponding with {@link PaginatedMessage.index}.
     * The handler will start collecting reactions and running actions once all actions have been reacted to the message.
     * @param message The message that triggered this {@link PaginatedMessage}.
     * Generally this will be the command message, but it can also be another message from your client, i.e. to indicate a loading state.
     * @param target The user who will be able to interact with the reactions of this {@link PaginatedMessage}. Defaults to `message.author`.
     */
    run(message: Message, target?: User): Promise<this>;
    /**
     * Executed whenever {@link PaginatedMessage.run} is called.
     */
    resolvePagesOnRun(channel: Message['channel']): Promise<void>;
    /**
     * Executed whenever an action is triggered and resolved.
     * @param index The index to resolve.
     */
    resolvePage(channel: Message['channel'], index: number): Promise<MessagePayload>;
    /**
     * Clones the current handler into a new instance.
     */
    clone(): PaginatedMessage;
    /**
     * Sets up the message.
     * @param channel The channel the handler is running at.
     * @param author The author the handler is for.
     */
    protected setUpMessage(channel: Message['channel'], author: User): Promise<void>;
    /**
     * Sets up the message's reactions and the collector.
     * @param channel The channel the handler is running at.
     * @param author The author the handler is for.
     */
    protected setUpReactions(channel: Message['channel'], author: User): Promise<void>;
    /**
     * Handles the load of a page.
     * @param page The page to be loaded.
     * @param channel The channel the paginated message runs at.
     * @param index The index of the current page.
     */
    protected handlePageLoad(page: MessagePage, channel: Message['channel'], index: number): Promise<MessagePayload>;
    /**
     * Handles the `collect` event from the collector.
     * @param author The the handler is for.
     * @param channel The channel the handler is running at.
     * @param reaction The reaction that was received.
     * @param user The user that reacted to the message.
     */
    protected handleCollect(author: User, channel: Message['channel'], reaction: MessageReaction, user: User): Promise<void>;
    /**
     * Handles the `end` event from the collector.
     * @param reason The reason for which the collector was ended.
     */
    protected handleEnd(_: Collection<Snowflake, MessageReaction>, reason: string): Promise<void>;
    protected applyFooter(message: MessagePayload, index: number): MessagePayload;
    private applyTemplate;
    private applyTemplateEmbed;
    private mergeEmbeds;
    private mergeArrays;
    /**
     * The default actions of this handler.
     */
    static defaultActions: IPaginatedMessageAction[];
    /**
     * The reasons sent by {@linkplain https://discord.js.org/#/docs/main/stable/class/ReactionCollector?scrollTo=e-end ReactionCollector#end}
     * event when the message (or its owner) has been deleted.
     */
    static deletionStopReasons: string[];
    /**
     * Custom prompt message when a user wants to jump to a certain page number.
     * @default "What page would you like to jump to?"
     * @remark To overwrite this property change it in a "setup" file prior to calling `client.login()` for your bot.
     * @example
     * ```typescript
     * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
     *
     * PaginatedMessage.promptMessage = 'Please send the number of the page you would like to jump to.';
     * ```
     */
    static promptMessage: string;
    /**
     * Custom text to show in front of the page index in the embed footer.
     * PaginatedMessage will automatically add a space (` `) after the given text. You do not have to add it yourself.
     * @default ""
     * @remark To overwrite this property change it somewhere in a "setup" file, i.e. where you also call `client.login()` for your bot.
     * @example
     * ```typescript
     * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
     *
     * PaginatedMessage.pageIndexPrefix = 'Page';
     * // This will make the footer of the embed something like "Page 1/2"
     * ```
     */
    static pageIndexPrefix: string;
    /**
     * The messages that are currently being handled by a {@link PaginatedMessage}
     * The key is the ID of the message that triggered this {@link PaginatedMessage}
     *
     * This is to ensure that only 1 {@link PaginatedMessage} can run on a specified message at once.
     * This is important when having an editable commands solution.
     */
    static readonly messages: Map<string, PaginatedMessage>;
    /**
     * The current {@link ReactionCollector} handlers that are active.
     * The key is the ID of of the author who sent the message that triggered this {@link PaginatedMessage}
     *
     * This is to ensure that any given author can only trigger 1 {@link PaginatedMessage}.
     * This is important for performance reasons, and users should not have more than 1 {@link PaginatedMessage} open at once.
     */
    static readonly handlers: Map<string, PaginatedMessage>;
    private static resolveTemplate;
}
export interface PaginatedMessage {
    constructor: typeof PaginatedMessage;
}
/**
 * To utilize actions you can use the {@link IPaginatedMessageAction} by implementing it into a class.
 * @example
 * ```typescript
 * class ForwardAction implements IPaginatedMessageAction {
 *   public id = '▶️';
 *
 *   public run({ handler }) {
 *     if (handler.index !== handler.pages.length - 1) ++handler.index;
 *   }
 * }
 *
 * // You can also give the object directly.
 *
 * const StopAction: IPaginatedMessageAction {
 *   id: '⏹️',
 *   disableResponseEdit: true,
 *   run: ({ response, collector }) => {
 *     await response.reactions.removeAll();
 *     collector!.stop();
 *   }
 * }
 * ```
 */
export interface IPaginatedMessageAction {
    id: string;
    run(context: PaginatedMessageActionContext): Awaited<unknown>;
}
/**
 * The context to be used in {@link IPaginatedMessageAction}.
 */
export interface PaginatedMessageActionContext {
    handler: PaginatedMessage;
    author: User;
    channel: Message['channel'];
    response: Message;
    collector: ReactionCollector;
}
export interface PaginatedMessageOptions {
    /**
     * The pages to display in this {@link PaginatedMessage}
     */
    pages?: MessagePage[];
    /**
     * Custom actions to provide when sending the paginated message
     */
    actions?: IPaginatedMessageAction[];
    /**
     * The {@link MessageEmbed} or {@link MessageOptions} options to apply to the entire {@link PaginatedMessage}
     */
    template?: MessageEmbed | MessageOptions;
    /**
     * @seealso {@link PaginatedMessage.pageIndexPrefix}
     */
    pageIndexPrefix?: string;
}
/**
 * The pages that are used for {@link PaginatedMessage.pages}
 *
 * Pages can be either a {@link MessagePayload},
 * or an awaited function that returns a {@link MessagePayload}.
 *
 * Furthermore, {@link MessageOptions} can be used to
 * construct the pages without state. This library also provides {@link MessageBuilder}, which can be used as a chainable
 * alternative to raw objects, similar to how {@link MessageEmbed}
 * works.
 *
 * Ideally, however, you should use the utility functions
 * {@link PaginatedMessage.addPageBuilder `addPageBuilder`}, {@link PaginatedMessage.addPageContent `addPageContent`}, and {@link PaginatedMessage.addPageEmbed `addPageEmbed`}
 * as opposed to manually constructing {@link MessagePage `MessagePages`}. This is because a {@link PaginatedMessage} does a lot of post-processing
 * on the provided pages and we can only guarantee this will work properly when using the utility methods.
 */
export declare type MessagePage = ((index: number, pages: MessagePage[], handler: PaginatedMessage) => Awaited<MessagePayload | MessageOptions>) | MessagePayload | MessageOptions;
//# sourceMappingURL=PaginatedMessage.d.ts.map