(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@sapphire/time-utilities')) :
	typeof define === 'function' && define.amd ? define(['exports', '@sapphire/time-utilities'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.SapphireRatelimits = {}, global.SapphireTimeUtilities));
}(this, (function (exports, timeUtilities) { 'use strict';

	class RateLimit {
	    /**
	     * @param manager The manager for this entry.
	     */
	    constructor(manager) {
	        /**
	         * The remaining amount of times this entry can be dripped before the bucket is empty.
	         */
	        Object.defineProperty(this, "remaining", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        /**
	         * The timestamp that represents when this entry will reset back to a available state.
	         */
	        Object.defineProperty(this, "expires", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        /**
	         * The {@link RateLimitManager} this entry is for.
	         */
	        Object.defineProperty(this, "manager", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        this.manager = manager;
	        this.reset();
	    }
	    /**
	     * Whether this entry is expired or not, allowing the bucket to be reset.
	     */
	    get expired() {
	        return this.remainingTime === 0;
	    }
	    /**
	     * Whether this entry is limited or not.
	     */
	    get limited() {
	        return this.remaining === 0 && !this.expired;
	    }
	    /**
	     * The remaining time in milliseconds before resetting.
	     */
	    get remainingTime() {
	        return Math.max(this.expires - Date.now(), 0);
	    }
	    /**
	     * Consumes {@link RateLimit.remaining} by one if it's not limited, calling {@link RateLimit.reset} first if {@link RateLimit.expired} is true.
	     */
	    consume() {
	        if (this.limited)
	            throw new Error('Cannot consume a limited bucket');
	        if (this.expired)
	            this.reset();
	        this.remaining--;
	        return this;
	    }
	    /**
	     * Resets the entry back to it's full state.
	     */
	    reset() {
	        return this.resetRemaining().resetTime();
	    }
	    /**
	     * Resets the entry's {@link RateLimit.remaining} uses back to full state.
	     */
	    resetRemaining() {
	        this.remaining = this.manager.limit;
	        return this;
	    }
	    /**
	     * Resets the entry's {@link RateLimit.expires} to the current time plus {@link RateLimitManager.time}.
	     */
	    resetTime() {
	        this.expires = Date.now() + this.manager.time;
	        return this;
	    }
	}

	class RateLimitManager extends Map {
	    /**
	     * @param limit The amount of times a {@link RateLimit} can drip before it's limited.
	     * @param time The amount of milliseconds for the ratelimits from this manager to expire.
	     */
	    constructor(time, limit = 1) {
	        super();
	        /**
	         * The amount of milliseconds for the {@link RateLimit ratelimits} from this manager to expire.
	         */
	        Object.defineProperty(this, "time", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        /**
	         * The amount of times a {@link RateLimit} can drip before it's limited.
	         */
	        Object.defineProperty(this, "limit", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        /**
	         * The interval to sweep expired {@link RateLimit ratelimits}.
	         */
	        Object.defineProperty(this, "sweepInterval", {
	            enumerable: true,
	            configurable: true,
	            writable: true,
	            value: void 0
	        });
	        this.time = time;
	        this.limit = limit;
	    }
	    /**
	     * Gets a {@link RateLimit} from this manager or creates it if it does not exist.
	     * @param id The id for the {@link RateLimit}
	     */
	    acquire(id) {
	        return this.get(id) ?? this.create(id);
	    }
	    /**
	     * Creates a {@link RateLimit} for this manager.
	     * @param id The id the {@link RateLimit} belongs to
	     */
	    create(id) {
	        const value = new RateLimit(this);
	        this.set(id, value);
	        return value;
	    }
	    /**
	     * Wraps Collection's set method to set interval to sweep inactive {@link RateLimit}s.
	     * @param id The id the {@link RateLimit} belongs to
	     * @param value The {@link RateLimit} to set
	     */
	    set(id, value) {
	        this.sweepInterval ?? (this.sweepInterval = timeUtilities.TimerManager.setInterval(this.sweep.bind(this), RateLimitManager.sweepIntervalDuration));
	        return super.set(id, value);
	    }
	    /**
	     * Wraps Collection's sweep method to clear the interval when this manager is empty.
	     */
	    sweep() {
	        for (const [id, value] of this.entries()) {
	            if (value.expired)
	                this.delete(id);
	        }
	        if (this.size === 0) {
	            timeUtilities.TimerManager.clearInterval(this.sweepInterval);
	            this.sweepInterval = null;
	        }
	    }
	}
	/**
	 * The delay in milliseconds for {@link RateLimitManager.sweepInterval}.
	 */
	Object.defineProperty(RateLimitManager, "sweepIntervalDuration", {
	    enumerable: true,
	    configurable: true,
	    writable: true,
	    value: 30000
	});

	exports.RateLimit = RateLimit;
	exports.RateLimitManager = RateLimitManager;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
